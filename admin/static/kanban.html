<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hAIveMind Agent Kanban Board</title>
    
    <!-- React and dependencies -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- React Beautiful DnD -->
    <script src="https://unpkg.com/react-beautiful-dnd@13.1.1/dist/react-beautiful-dnd.min.js"></script>
    
    <!-- Chart.js for analytics -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <!-- Styles -->
    <link rel="stylesheet" href="/admin/static/js/components/kanban/KanbanBoard.css">
    
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        #root {
            min-height: 100vh;
        }
        
        .page-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        .page-header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 700;
        }
        
        .page-header p {
            margin: 10px 0 0 0;
            opacity: 0.9;
            font-size: 1.1em;
        }
        
        .loading-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid #fff;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .error-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
            text-align: center;
            padding: 20px;
        }
        
        .error-screen h2 {
            margin-bottom: 20px;
            font-size: 2em;
        }
        
        .error-screen p {
            margin-bottom: 30px;
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .retry-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            padding: 12px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .retry-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }
    </style>
</head>
<body>
    <div id="root">
        <div class="loading-screen">
            <div class="loading-spinner"></div>
            <h2>Loading hAIveMind Kanban Board...</h2>
            <p>Initializing agent coordination system</p>
        </div>
    </div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        const { DragDropContext, Droppable, Draggable } = window.ReactBeautifulDnd;

        // Main Application Component
        const KanbanApp = () => {
            const [isLoading, setIsLoading] = useState(true);
            const [error, setError] = useState(null);
            const [boardData, setBoardData] = useState({
                columns: ['backlog', 'assigned', 'in_progress', 'review', 'done'],
                tasks: {},
                agents: [],
                metrics: {},
                wip_limits: {}
            });
            const [agents, setAgents] = useState([]);
            const [selectedTask, setSelectedTask] = useState(null);
            const [showCreateModal, setShowCreateModal] = useState(false);
            const [showAnalytics, setShowAnalytics] = useState(false);
            const wsRef = useRef(null);

            useEffect(() => {
                initializeApp();
                return () => {
                    if (wsRef.current) {
                        wsRef.current.close();
                    }
                };
            }, []);

            const initializeApp = async () => {
                try {
                    setError(null);
                    await Promise.all([
                        loadBoardData(),
                        loadAgents()
                    ]);
                    
                    // Connect WebSocket for real-time updates
                    connectWebSocket();
                    
                } catch (error) {
                    console.error('Failed to initialize app:', error);
                    setError(error.message || 'Failed to load kanban board');
                } finally {
                    setIsLoading(false);
                }
            };

            const loadBoardData = async () => {
                const response = await fetch('/api/kanban/boards/default?metrics=true');
                if (!response.ok) {
                    throw new Error(`Failed to load board: ${response.status}`);
                }
                const data = await response.json();
                if (data.board) {
                    setBoardData(data.board);
                } else {
                    // Create default board structure if empty
                    setBoardData(prev => ({
                        ...prev,
                        id: 'default',
                        name: 'hAIveMind Agent Board',
                        tasks: {
                            backlog: [],
                            assigned: [],
                            in_progress: [],
                            review: [],
                            done: []
                        }
                    }));
                }
            };

            const loadAgents = async () => {
                const response = await fetch('/api/kanban/agents');
                if (!response.ok) {
                    throw new Error(`Failed to load agents: ${response.status}`);
                }
                const data = await response.json();
                if (data.agents) {
                    setAgents(data.agents);
                }
            };

            const connectWebSocket = () => {
                try {
                    // Use current host for WebSocket connection
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    const wsUrl = `${protocol}//${window.location.host}/ws/kanban`;
                    
                    wsRef.current = new WebSocket(wsUrl);
                    
                    wsRef.current.onopen = () => {
                        console.log('WebSocket connected for real-time updates');
                    };
                    
                    wsRef.current.onmessage = (event) => {
                        try {
                            const message = JSON.parse(event.data);
                            if (message.type === 'kanban_update') {
                                handleRealtimeUpdate(message.data);
                            }
                        } catch (error) {
                            console.error('Failed to parse WebSocket message:', error);
                        }
                    };
                    
                    wsRef.current.onclose = () => {
                        console.log('WebSocket disconnected, reconnecting...');
                        // Reconnect after 3 seconds
                        setTimeout(connectWebSocket, 3000);
                    };
                    
                    wsRef.current.onerror = (error) => {
                        console.error('WebSocket error:', error);
                    };
                } catch (error) {
                    console.warn('WebSocket connection failed:', error);
                }
            };

            const handleRealtimeUpdate = (updateData) => {
                if (updateData.type === 'task_moved') {
                    // Update task position in real-time
                    setBoardData(prev => {
                        const newTasks = { ...prev.tasks };
                        const task = findTaskById(updateData.taskId);
                        if (task) {
                            // Remove from old column
                            Object.keys(newTasks).forEach(column => {
                                newTasks[column] = newTasks[column].filter(t => t.id !== updateData.taskId);
                            });
                            
                            // Add to new column
                            task.status = updateData.newStatus;
                            if (!newTasks[updateData.newStatus]) {
                                newTasks[updateData.newStatus] = [];
                            }
                            newTasks[updateData.newStatus] = [...newTasks[updateData.newStatus], task];
                        }
                        return { ...prev, tasks: newTasks };
                    });
                }
            };

            const findTaskById = (taskId) => {
                for (const column of Object.keys(boardData.tasks)) {
                    const task = boardData.tasks[column]?.find(t => t.id === taskId);
                    if (task) return task;
                }
                return null;
            };

            const handleDragEnd = async (result) => {
                const { destination, source, draggableId } = result;

                if (!destination || 
                    (destination.droppableId === source.droppableId && 
                     destination.index === source.index)) {
                    return;
                }

                const task = findTaskById(draggableId);
                if (!task) return;

                // Check WIP limits
                const newColumn = destination.droppableId;
                const wipLimit = boardData.wip_limits[newColumn];
                if (wipLimit && (boardData.tasks[newColumn]?.length || 0) >= wipLimit) {
                    alert(`WIP limit reached for ${newColumn} (${boardData.tasks[newColumn]?.length || 0}/${wipLimit})`);
                    return;
                }

                // Optimistic update
                const newTasks = { ...boardData.tasks };
                if (newTasks[source.droppableId]) {
                    newTasks[source.droppableId] = newTasks[source.droppableId].filter(t => t.id !== draggableId);
                }
                
                task.status = newColumn;
                if (!newTasks[newColumn]) {
                    newTasks[newColumn] = [];
                }
                
                const destTasks = [...newTasks[newColumn]];
                destTasks.splice(destination.index, 0, task);
                newTasks[newColumn] = destTasks;

                setBoardData(prev => ({ ...prev, tasks: newTasks }));

                // Send update to server
                try {
                    const response = await fetch(`/api/kanban/tasks/${draggableId}/move`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            status: newColumn,
                            moved_by: 'web_user'
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to move task');
                    }
                } catch (error) {
                    console.error('Failed to move task:', error);
                    // Revert optimistic update
                    loadBoardData();
                }
            };

            const createTask = async (taskData) => {
                try {
                    const response = await fetch('/api/kanban/tasks', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            ...taskData,
                            created_by: 'web_user',
                            board_id: 'default'
                        })
                    });

                    if (response.ok) {
                        await loadBoardData();
                        setShowCreateModal(false);
                    } else {
                        throw new Error('Failed to create task');
                    }
                } catch (error) {
                    console.error('Failed to create task:', error);
                    alert('Failed to create task. Please try again.');
                }
            };

            const assignTask = async (taskId, agentId) => {
                try {
                    const response = await fetch(`/api/kanban/tasks/${taskId}/assign`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            agent_id: agentId,
                            auto_assign: !agentId
                        })
                    });
                    
                    if (response.ok) {
                        await loadBoardData();
                    } else {
                        throw new Error('Failed to assign task');
                    }
                } catch (error) {
                    console.error('Failed to assign task:', error);
                    alert('Failed to assign task. Please try again.');
                }
            };

            if (error) {
                return (
                    <div className="error-screen">
                        <h2>‚ö†Ô∏è Connection Error</h2>
                        <p>{error}</p>
                        <button className="retry-btn" onClick={initializeApp}>
                            Retry Connection
                        </button>
                    </div>
                );
            }

            if (isLoading) {
                return (
                    <div className="loading-screen">
                        <div className="loading-spinner"></div>
                        <h2>Loading hAIveMind Kanban Board...</h2>
                        <p>Initializing agent coordination system</p>
                    </div>
                );
            }

            return (
                <div>
                    <div className="page-header">
                        <h1>üß† hAIveMind Agent Kanban</h1>
                        <p>Intelligent Task Management & Agent Coordination System</p>
                    </div>
                    
                    <KanbanBoard 
                        boardData={boardData}
                        agents={agents}
                        onDragEnd={handleDragEnd}
                        onCreateTask={createTask}
                        onAssignTask={assignTask}
                        onRefresh={loadBoardData}
                        showAnalytics={showAnalytics}
                        onToggleAnalytics={() => setShowAnalytics(!showAnalytics)}
                        selectedTask={selectedTask}
                        onSelectTask={setSelectedTask}
                        showCreateModal={showCreateModal}
                        onShowCreateModal={setShowCreateModal}
                    />
                </div>
            );
        };

        // Kanban Board Component
        const KanbanBoard = ({ 
            boardData, 
            agents, 
            onDragEnd, 
            onCreateTask, 
            onAssignTask, 
            onRefresh, 
            showAnalytics, 
            onToggleAnalytics,
            selectedTask,
            onSelectTask,
            showCreateModal,
            onShowCreateModal
        }) => {
            const getColumnStyle = (columnId) => {
                const taskCount = boardData.tasks[columnId]?.length || 0;
                const wipLimit = boardData.wip_limits[columnId];
                
                if (wipLimit && taskCount >= wipLimit) {
                    return { borderColor: '#ff4757', borderWidth: '2px' };
                } else if (wipLimit && taskCount >= wipLimit * 0.8) {
                    return { borderColor: '#ffa502', borderWidth: '2px' };
                }
                
                return {};
            };

            return (
                <div className="kanban-board">
                    <div className="kanban-header">
                        <h1>{boardData.name || 'Agent Kanban Board'}</h1>
                        <div className="kanban-actions">
                            <button 
                                className="btn btn-primary"
                                onClick={() => onShowCreateModal(true)}
                            >
                                ‚ûï Create Task
                            </button>
                            <button 
                                className="btn btn-secondary"
                                onClick={onToggleAnalytics}
                            >
                                üìä {showAnalytics ? 'Hide' : 'Show'} Analytics
                            </button>
                            <button className="btn btn-secondary" onClick={onRefresh}>
                                üîÑ Refresh
                            </button>
                        </div>
                    </div>

                    {showAnalytics && boardData.metrics && (
                        <KanbanAnalytics metrics={boardData.metrics} />
                    )}

                    <div className="agents-panel">
                        <h3>ü§ñ Active Agents ({agents.filter(a => a.status === 'active').length})</h3>
                        <div className="agents-grid">
                            {agents.map(agent => (
                                <AgentCard key={agent.id} agent={agent} />
                            ))}
                        </div>
                    </div>

                    <DragDropContext onDragEnd={onDragEnd}>
                        <div className="kanban-columns">
                            {boardData.columns.map(columnId => {
                                const columnTasks = boardData.tasks[columnId] || [];
                                const wipLimit = boardData.wip_limits[columnId];
                                
                                return (
                                    <div 
                                        key={columnId} 
                                        className="kanban-column"
                                        style={getColumnStyle(columnId)}
                                    >
                                        <div className="column-header">
                                            <h3>{columnId.replace('_', ' ').toUpperCase()}</h3>
                                            <div className="column-meta">
                                                <span className="task-count">{columnTasks.length}</span>
                                                {wipLimit && (
                                                    <span className="wip-limit">/ {wipLimit}</span>
                                                )}
                                            </div>
                                        </div>

                                        <Droppable droppableId={columnId}>
                                            {(provided, snapshot) => (
                                                <div
                                                    ref={provided.innerRef}
                                                    {...provided.droppableProps}
                                                    className={`column-tasks ${snapshot.isDraggingOver ? 'dragging-over' : ''}`}
                                                >
                                                    {columnTasks.map((task, index) => (
                                                        <Draggable
                                                            key={task.id}
                                                            draggableId={task.id}
                                                            index={index}
                                                        >
                                                            {(provided, snapshot) => (
                                                                <TaskCard
                                                                    task={task}
                                                                    provided={provided}
                                                                    snapshot={snapshot}
                                                                    agents={agents}
                                                                    onAssign={(agentId) => onAssignTask(task.id, agentId)}
                                                                    onClick={() => onSelectTask(task)}
                                                                />
                                                            )}
                                                        </Draggable>
                                                    ))}
                                                    {provided.placeholder}
                                                </div>
                                            )}
                                        </Droppable>
                                    </div>
                                );
                            })}
                        </div>
                    </DragDropContext>

                    {showCreateModal && (
                        <TaskCreateModal
                            onClose={() => onShowCreateModal(false)}
                            onCreate={onCreateTask}
                            agents={agents}
                        />
                    )}

                    {selectedTask && (
                        <TaskDetailModal
                            task={selectedTask}
                            agents={agents}
                            onClose={() => onSelectTask(null)}
                            onUpdate={onRefresh}
                        />
                    )}
                </div>
            );
        };

        // Task Card Component
        const TaskCard = ({ task, provided, snapshot, agents, onAssign, onClick }) => {
            const assignedAgent = agents.find(a => a.id === task.assigned_agent);
            const priorityColors = {
                critical: '#ff3838',
                high: '#ff6b35', 
                medium: '#f7b731',
                low: '#20bf6b'
            };

            return (
                <div
                    ref={provided.innerRef}
                    {...provided.draggableProps}
                    {...provided.dragHandleProps}
                    className={`task-card priority-${task.priority} ${snapshot.isDragging ? 'dragging' : ''}`}
                    onClick={onClick}
                >
                    <div className="task-header">
                        <span 
                            className="priority-indicator"
                            style={{ backgroundColor: priorityColors[task.priority] }}
                        ></span>
                        <h4>{task.title}</h4>
                    </div>
                    
                    {task.description && (
                        <p className="task-description">{task.description.substring(0, 100)}...</p>
                    )}

                    <div className="task-meta">
                        {assignedAgent && (
                            <div className="assigned-agent">
                                <img 
                                    src={`https://api.dicebear.com/6.x/initials/svg?seed=${assignedAgent.name}`}
                                    alt={assignedAgent.name}
                                    className="agent-avatar"
                                />
                                <span>{assignedAgent.name}</span>
                            </div>
                        )}
                        
                        {task.estimated_hours && (
                            <span className="time-estimate">{task.estimated_hours}h</span>
                        )}
                        
                        {task.tags && task.tags.length > 0 && (
                            <div className="task-tags">
                                {task.tags.slice(0, 2).map(tag => (
                                    <span key={tag} className="task-tag">{tag}</span>
                                ))}
                                {task.tags.length > 2 && <span className="more-tags">+{task.tags.length - 2}</span>}
                            </div>
                        )}
                    </div>

                    {!assignedAgent && task.status === 'backlog' && (
                        <button 
                            className="auto-assign-btn"
                            onClick={(e) => {
                                e.stopPropagation();
                                onAssign(null);
                            }}
                        >
                            ü§ñ Auto-assign
                        </button>
                    )}
                </div>
            );
        };

        // Continue with other components...
        // (Including AgentCard, KanbanAnalytics, TaskCreateModal, TaskDetailModal)

        // Simplified components for the demo
        const AgentCard = ({ agent }) => {
            const statusColors = {
                active: '#20bf6b',
                busy: '#f7b731', 
                offline: '#95a5a6',
                maintenance: '#e55039'
            };

            const workloadPercentage = (agent.current_workload / agent.max_workload) * 100;

            return (
                <div className="agent-card">
                    <div className="agent-header">
                        <img 
                            src={`https://api.dicebear.com/6.x/initials/svg?seed=${agent.name}`}
                            alt={agent.name}
                            className="agent-avatar"
                        />
                        <div className="agent-info">
                            <h4>{agent.name}</h4>
                            <span 
                                className="agent-status"
                                style={{ color: statusColors[agent.status] }}
                            >
                                {agent.status}
                            </span>
                        </div>
                    </div>
                    
                    <div className="workload-bar">
                        <div 
                            className="workload-fill"
                            style={{ 
                                width: `${workloadPercentage}%`,
                                backgroundColor: workloadPercentage > 80 ? '#e55039' : '#20bf6b'
                            }}
                        ></div>
                        <span className="workload-text">
                            {agent.current_workload}/{agent.max_workload}
                        </span>
                    </div>

                    {agent.capabilities && agent.capabilities.length > 0 && (
                        <div className="agent-capabilities">
                            {agent.capabilities.slice(0, 3).map(cap => (
                                <span key={cap.name} className="capability-tag">
                                    {cap.name} ({cap.level})
                                </span>
                            ))}
                        </div>
                    )}
                </div>
            );
        };

        const KanbanAnalytics = ({ metrics }) => {
            if (!metrics) return null;

            return (
                <div className="kanban-analytics">
                    <div className="metrics-grid">
                        <div className="metric-card">
                            <h4>‚è±Ô∏è Cycle Time</h4>
                            <span className="metric-value">
                                {metrics.avg_cycle_time_hours?.toFixed(1) || 0}h
                            </span>
                        </div>
                        <div className="metric-card">
                            <h4>üöÄ Weekly Throughput</h4>
                            <span className="metric-value">{metrics.weekly_throughput || 0}</span>
                        </div>
                        <div className="metric-card">
                            <h4>üîÑ Active Tasks</h4>
                            <span className="metric-value">
                                {(metrics.status_counts?.in_progress || 0) + (metrics.status_counts?.assigned || 0)}
                            </span>
                        </div>
                        <div className="metric-card">
                            <h4>‚úÖ Completed</h4>
                            <span className="metric-value">{metrics.status_counts?.done || 0}</span>
                        </div>
                    </div>
                </div>
            );
        };

        const TaskCreateModal = ({ onClose, onCreate, agents }) => {
            const [formData, setFormData] = React.useState({
                title: '',
                description: '',
                priority: 'medium',
                estimated_hours: '',
                tags: '',
                assigned_agent: ''
            });

            const handleSubmit = (e) => {
                e.preventDefault();
                const taskData = {
                    ...formData,
                    tags: formData.tags.split(',').map(t => t.trim()).filter(t => t),
                    estimated_hours: formData.estimated_hours ? parseInt(formData.estimated_hours) : null,
                    assigned_agent: formData.assigned_agent || null
                };
                onCreate(taskData);
            };

            return (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="modal-content" onClick={e => e.stopPropagation()}>
                        <div className="modal-header">
                            <h3>‚ûï Create New Task</h3>
                            <button className="modal-close" onClick={onClose}>&times;</button>
                        </div>

                        <form onSubmit={handleSubmit}>
                            <div className="form-group">
                                <label>Title</label>
                                <input
                                    type="text"
                                    required
                                    value={formData.title}
                                    onChange={e => setFormData({...formData, title: e.target.value})}
                                    placeholder="Enter task title..."
                                />
                            </div>

                            <div className="form-group">
                                <label>Description</label>
                                <textarea
                                    rows={4}
                                    value={formData.description}
                                    onChange={e => setFormData({...formData, description: e.target.value})}
                                    placeholder="Describe the task..."
                                />
                            </div>

                            <div className="form-row">
                                <div className="form-group">
                                    <label>Priority</label>
                                    <select
                                        value={formData.priority}
                                        onChange={e => setFormData({...formData, priority: e.target.value})}
                                    >
                                        <option value="low">üîµ Low</option>
                                        <option value="medium">üü° Medium</option>
                                        <option value="high">üü† High</option>
                                        <option value="critical">üî¥ Critical</option>
                                    </select>
                                </div>

                                <div className="form-group">
                                    <label>Estimated Hours</label>
                                    <input
                                        type="number"
                                        min="1"
                                        value={formData.estimated_hours}
                                        onChange={e => setFormData({...formData, estimated_hours: e.target.value})}
                                        placeholder="Hours"
                                    />
                                </div>
                            </div>

                            <div className="form-group">
                                <label>Assign to Agent</label>
                                <select
                                    value={formData.assigned_agent}
                                    onChange={e => setFormData({...formData, assigned_agent: e.target.value})}
                                >
                                    <option value="">ü§ñ Auto-assign</option>
                                    {agents.filter(a => a.status === 'active').map(agent => (
                                        <option key={agent.id} value={agent.id}>
                                            {agent.name} ({agent.current_workload}/{agent.max_workload})
                                        </option>
                                    ))}
                                </select>
                            </div>

                            <div className="form-group">
                                <label>Tags (comma-separated)</label>
                                <input
                                    type="text"
                                    placeholder="bug, feature, urgent"
                                    value={formData.tags}
                                    onChange={e => setFormData({...formData, tags: e.target.value})}
                                />
                            </div>

                            <div className="modal-actions">
                                <button type="button" className="btn btn-secondary" onClick={onClose}>
                                    Cancel
                                </button>
                                <button type="submit" className="btn btn-primary">
                                    Create Task
                                </button>
                            </div>
                        </form>
                    </div>
                </div>
            );
        };

        const TaskDetailModal = ({ task, agents, onClose }) => {
            const assignedAgent = agents.find(a => a.id === task.assigned_agent);

            return (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="modal-content task-detail-modal" onClick={e => e.stopPropagation()}>
                        <div className="modal-header">
                            <h3>üìã {task.title}</h3>
                            <button className="modal-close" onClick={onClose}>&times;</button>
                        </div>

                        <div className="task-detail-content">
                            <div className="task-meta-detailed">
                                <span className={`priority-badge priority-${task.priority}`}>
                                    {task.priority.toUpperCase()}
                                </span>
                                <span className={`status-badge status-${task.status}`}>
                                    {task.status.replace('_', ' ').toUpperCase()}
                                </span>
                            </div>

                            <div className="task-description-full">
                                <h4>üìù Description</h4>
                                <p>{task.description || 'No description provided'}</p>
                            </div>

                            {assignedAgent && (
                                <div className="assigned-agent-detail">
                                    <h4>üë§ Assigned Agent</h4>
                                    <AgentCard agent={assignedAgent} />
                                </div>
                            )}

                            <div className="task-timeline">
                                <h4>‚è∞ Timeline</h4>
                                <p>Created: {new Date(task.created_at).toLocaleString()}</p>
                                <p>Updated: {new Date(task.updated_at).toLocaleString()}</p>
                                {task.due_date && <p>Due: {new Date(task.due_date).toLocaleString()}</p>}
                            </div>

                            {task.tags && task.tags.length > 0 && (
                                <div className="task-tags-detail">
                                    <h4>üè∑Ô∏è Tags</h4>
                                    {task.tags.map(tag => (
                                        <span key={tag} className="task-tag">{tag}</span>
                                    ))}
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        // Render the application
        ReactDOM.render(<KanbanApp />, document.getElementById('root'));
    </script>
</body>
</html>